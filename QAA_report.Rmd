---
title: "QAA_report"
author: "Abraham Solomon"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(png)
library(grid)
library(gridExtra)
library(tinytex)
require(pander)
```
## **Part 1**


The per base quality distribution for both *control* reads and both *both* reads meets satisfactory targets and is consistent with the substantial absence of N content per base (Fig. 1, Fig 2).

The per base quality score distribution for each file generated by my in house `qual_score_dist.py` python script is effectively equivalent to the distributions produced by FastQC. The total run time was approximately equivalent because while FastQC has capability to process all four files simultaneously with multithreading unlike my `qual_score_dist.py` python script, it also generates more plots than my `qual_score_dist.py` python script such as per base N content which evens out the total run time to ~8 minutes.

With zero overrepresented sequences for read 1 control, read 1 experimental and read 2 experimental reads, the data appears to be consistently high quality.


```{r fig.width=7, fig.height=10, fig.cap="Figure 1. Per base quality score distribution comparison between by FastQC and an in-house python script. **(A, C, E, G)** were generated by my in-house python script. **(B, D, F, H)** were generated by FastQC. **(A, B)** is *3_2B_control_S3 R1* **(C, D)** is  *3_2B_control_S3 R2* **(E, F)** is *32_4G_both_R1*, **(G, H)** is *32_4G_both_R2*." , echo=FALSE}

perbase_seq_qual_me_control1 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/my_qual_score_distributions/3_2B_control_S3_L008_R1_001.png")
perbase_seq_qual_fastqc_control1 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/3_2B_control_S3_L008_R1_001_fastqc/Images/per_base_quality.png")
perbase_seq_qual_me_control2 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/my_qual_score_distributions/3_2B_control_S3_L008_R1_001.png")
perbase_seq_qual_fastqc_control2 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/3_2B_control_S3_L008_R2_001_fastqc/Images/per_base_quality.png")

perbase_seq_qual_me_both1 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/my_qual_score_distributions/32_4G_both_S23_L008_R1_001_distribution.png")
perbase_seq_qual_fastqc_both1 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/32_4G_both_S23_L008_R1_001_fastqc/Images/per_base_quality.png")
perbase_seq_qual_me_both2 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/my_qual_score_distributions/32_4G_both_S23_L008_R2_001_distribution.png")
perbase_seq_qual_fastqc_both2 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/32_4G_both_S23_L008_R2_001_fastqc/Images/per_base_quality.png")

grid.arrange(rasterGrob(perbase_seq_qual_me_control1),
             rasterGrob(perbase_seq_qual_fastqc_control1),
             nullGrob(),
             nullGrob(),
             rasterGrob(perbase_seq_qual_me_control2),
             rasterGrob(perbase_seq_qual_fastqc_control2),
             nullGrob(),
             nullGrob(),
             rasterGrob(perbase_seq_qual_me_both1),
             rasterGrob(perbase_seq_qual_fastqc_both1),
             nullGrob(),
             nullGrob(),
             rasterGrob(perbase_seq_qual_me_both2),
             rasterGrob(perbase_seq_qual_fastqc_both2),
             nrow =7, heights = c(0.5, 0.05, 0.5, 0.05, 0.5, 0.05, 0.5),
             widths = c(0.95, 0.95)
)

grid.text("A", x=unit(0.010, "npc"), y=unit(0.995, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("B", x=unit(0.518, "npc"), y=unit(0.995, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("C", x=unit(0.010, "npc"), y=unit(0.735, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("D", x=unit(0.518, "npc"), y=unit(0.735, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("E", x=unit(0.010, "npc"), y=unit(0.485, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("F", x=unit(0.518, "npc"), y=unit(0.485, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("G", x=unit(0.010, "npc"), y=unit(0.225, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("H", x=unit(0.518, "npc"), y=unit(0.225, "npc"), gp=gpar(fontsize=10, col="grey25"))
```

```{r fig.width=7, fig.height=6, fig.cap="Figure 2. N content across all bases for **(A)** *sample 3_2B_control_S3_R1*, **(B)** *3_2B_control_S3_R2*, **(C)** *32_4G_both_S23_R1*, **(D)** *32_4G_both_S23_R2* generated by FastQC.", echo=FALSE}

perbase_ncontent_control1 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/3_2B_control_S3_L008_R1_001_fastqc/Images/per_base_n_content.png")
perbase_ncontent_control2 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/3_2B_control_S3_L008_R2_001_fastqc/Images/per_base_n_content.png")
perbase_ncontent_both1 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/32_4G_both_S23_L008_R1_001_fastqc/Images/per_base_n_content.png")
perbase_ncontent_both2 = readPNG("/Users/abrahamsolomon/bioinfo/Bi623/QAA/FASTQC_OUTPUT/32_4G_both_S23_L008_R2_001_fastqc/Images/per_base_n_content.png")


grid.arrange(rasterGrob(perbase_ncontent_control1),
             rasterGrob(perbase_ncontent_control2),
             rasterGrob(perbase_ncontent_both1),
             rasterGrob(perbase_ncontent_both2),
             nrow = 2, heights = c(0.2, 0.2),
             widths = c(0.95, 0.95)
)

grid.text("A", x=unit(0.010, "npc"), y=unit(0.965, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("B", x=unit(0.518, "npc"), y=unit(0.965, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("C", x=unit(0.010, "npc"), y=unit(0.47, "npc"), gp=gpar(fontsize=10, col="grey25"))
grid.text("D", x=unit(0.518, "npc"), y=unit(0.470, "npc"), gp=gpar(fontsize=10, col="grey25"))

```

## **Part 2**


*3_2B_control* libraries were prepared using an Illumina TruSeq paired-end library kit making each read strand specific where R1 and R2 correspond to the forward and reverse reads respectively. However, because *32_4G_both* samples were not prepared using a strand specific library, R1 and R2 reads are not strand specific and thus we expect to see equivalent adapter trimming for R1 and R2. After adapter trimming with Cutadapt, quality filtering with Trimmomatic to remove artifacts from sequencing, and plotting the distributiobn of read lengths for each sample type we find that the reverse read for *3_2B_control* (R2) maintained a higher number of reads with larger lengths suggesting less adapter content and higher quality than the forward read. It is expected that the forward read would have 

Plotting the read length distribution for *32_4G_both* samples confirmed the postulate that these reads were not strand specific because all reads, both R1 and R2, were equally trimmed. By overlaying the read length distribution of R1 and R2 at 50% opacity we see that only one line is shown and in purple suggesting a perfect mixing of R1 and R2 for the frequency of different read lengths.

```{r fig.width=7, fig.height=6.5, fig.cap="Figure 3. **(A)** Read Length distribution for 3_2B_control and **(B)** 32_4G_both after trimming the adapter sequences with cutadapt and quality filtering with Trimmomatic. The library of **(A)** is strand non-specific so read 1 (R1) and read 2 (R2) are not forward or reverse. ", echo=FALSE, results = 'hide'}

df_32_4G_both_S23_L008_R1P_001.read_length <- read.delim("~/bioinfo/Bi623/QAA/trims/sans_adapt_32_4G_both_S23_L008_R1P_001.read_length", sep = "", header = TRUE) %>% 
  mutate("Strand" = "R1")
colnames(df_32_4G_both_S23_L008_R1P_001.read_length) <- c("Frequency", "Read Length", "Strand")

#R> colnames(X) <- c("good", "better")
df_32_4G_both_S23_L008_R2P_001.read_length <- read.delim("~/bioinfo/Bi623/QAA/trims/sans_adapt_32_4G_both_S23_L008_R2P_001.read_length", sep = "", header = TRUE) %>% mutate("Strand" = "R2")
colnames(df_32_4G_both_S23_L008_R2P_001.read_length) <- c("Frequency", "Read Length", "Strand")


df_3_2B_control_S3_L008_R1P_001.read_length <- read.delim("~/bioinfo/Bi623/QAA/trims/sans_adapt_3_2B_control_S3_L008_R1P_001.read_length", sep = "", header = TRUE) %>% mutate("Strand" = "Forward")
colnames(df_3_2B_control_S3_L008_R1P_001.read_length) <- c("Frequency", "Read Length", "Strand")

df_3_2B_control_S3_L008_R2P_001.read_length <- read.delim("~/bioinfo/Bi623/QAA/trims/sans_adapt_3_2B_control_S3_L008_R2P_001.read_length", sep = "", header = TRUE) %>% mutate("Strand" = "Reverse")
colnames(df_3_2B_control_S3_L008_R2P_001.read_length) <- c("Frequency", "Read Length", "Strand")


merged_df_32_4G_both_S23_L008 <- rbind(df_32_4G_both_S23_L008_R1P_001.read_length, df_32_4G_both_S23_L008_R2P_001.read_length)

merged_df_3_2B_control_S3_L008 <- rbind(df_3_2B_control_S3_L008_R1P_001.read_length, df_3_2B_control_S3_L008_R2P_001.read_length)

both_read_length_plot <- ggplot(merged_df_32_4G_both_S23_L008, aes(x = `Read Length`, y = Frequency, color = Strand)) +
    geom_line(stat = "identity", position = "identity", alpha = 0.5) +
    scale_y_log10() +  # Set y-axis to log10 scale
    scale_color_manual(values = c("R1" = "blue", "R2" = "red"))  
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.margin = unit(c(2, 0.5, 0.5, 0.5), "cm")
    )

control_read_length_plot <- ggplot(merged_df_3_2B_control_S3_L008, aes(x = `Read Length`, y = Frequency, color = Strand)) +
    geom_line(stat = "identity", position = "identity", alpha = 0.5) +
    scale_y_log10() +  # Set y-axis to log10 scale
    scale_color_manual(values = c("Forward" = "blue", "Reverse" = "red"))  
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.margin = unit(c(2, 0.5, 0.5, 5), "cm")
    )

grid.arrange(both_read_length_plot,
             nullGrob(),
             control_read_length_plot,
             nrow =3,  heights = c(.5, .1, .5), top = textGrob("\n"))

grid.text("A", x=unit(0.020, "npc"), y=unit(0.95, "npc"), gp=gpar(fontsize=15, col="grey25"))
grid.text("B", x=unit(0.020, "npc"), y=unit(0.45, "npc"), gp=gpar(fontsize=15, col="grey25"))
```

## **Part 3**


All sample reads were aligned to the *Mus musculus* mouse reference genome using STAR and the number of transcripts that map to genes in this reference genome were counted using two methods HTSeq-count and an in-house sequence feature map counting script called `mapcounts.py` (Table 1, Table 2). 

If the total number of features (mapped and unmapped) for either the forward or reverse read are summed, doubled and equal the number of features counted with `mapcounts.py` then the original library used was strand-specific giving rise to stranded RNA-seq reads. This is because the stranded option from HTSeq-count is checking for only the forward or reverse strand to the reference genome but `mapcounts.py` is not and so to get the total number of genes that were counted, you must double all outputs from HTSeq-count. If the HTSeq-count doubled total does not match `mapcounts.py` then the library was not stranded. As shown in Table 1 shows that when the total gene count for the forward read is doubled, it equals the `mapcounts.py` total allowing us to confidently say that *3_2B_control* is stranded. Additionally in Table 2, we see a large difference in genes mapped to the reference genome between the forward and reverse reads providing further evidence that this library was stranded. 

The same cannot be said for *32_4G_Both* reads because the percentage of genes that map the mouse reference genome are equal between R1 and R2. Additionally, the same rule of gene count totals does not apply.


Ultimately, I would suggest that we move forward with analyzing this data because it has maintained high quality reads with low N content, low adapter content, and trimming has not reduced the number of genes that can map to the genome too much.


```{r table1, echo=FALSE, results='asis'}
require(pander)
panderOptions('table.split.table', Inf)

# Set caption for Table 1
set.caption("The number of transcripts successfully mapped to genes in the mouse reference genome for forward versus reverse reads counted with HTSeq-count and `mapcounts.py`.")

# Create the data frame for Table 1
table_df1 <- data.frame(
  `HTSeq-count` = c("HTSeq-count forward", "HTSeq-count reverse", "`mapcounts.py`"),
  `3_2B_control` = c(6428019, 1389506, 12856038),
  `32_4G_both` = c(12021662, 12021660, 23600576)
)

# Render the table using pander
pander(table_df1)
```

```{r table2, echo=FALSE, results='asis'}
require(pander)
panderOptions('table.split.table', Inf)

# Set caption for Table 2
set.caption("Percent of genes successfully mapped to the mouse reference genome counted with HTSeq-count.")

# Create the data frame for Table 2
table_df2 <- data.frame(
  `HTSeq-count` = c("3_2B_control", "32_4G_both"),
  `Percent Stranded Forward` = c(3.45, 1.84),
  `Percent Reverse` = c(15.95, 1.84)
)

# Render the table using pander
pander(table_df2)
```

```{r table3, echo=FALSE, results='asis'}
require(pander)
panderOptions('table.split.table', Inf)

# Set caption for Table 3
set.caption("The number of transcripts that did and did not successfully map to genes in the mouse reference genome for forward and reverse reads counted with `mapcounts.py`.")

# Create the data frame for Table 3
#table_df3 <- data.frame(
#  `mapcounts.py` = c("Mapped", "Unmapped"),
#  `3_2B_control` = c(12359963, 168582, 12856038),
#  `32_4G_both` = c(496075, 23431994, 23600576),
#  `Total` = c(12359963, 496075)
#)

table_df3 <- data.frame(
  `mapcounts.py` = c("Mapped", "Unmapped", "Total"),
  `3_2B_control` = c(12359963, 496075, 12856038),
  `32_4G_both` = c(168582, 23431994, 23600576)
)

# Render the table using pander
pander(table_df3)
```






```{r echo=FALSE, results = FALSE}

#1
df_stranded_3_2B_control_S3_L008.genecount <- read.delim("~/bioinfo/Bi623/QAA/star/alignment/stranded_3_2B_control_S3_L008.genecount", sep = "", header = TRUE) #%>% mutate("Strand" = "Forward")
mapped_stranded_control <- sum(df_stranded_3_2B_control_S3_L008.genecount$count)

#2
df_reverse_3_2B_control_S3_L008.genecount <- read.delim("~/bioinfo/Bi623/QAA/star/alignment/reverse_3_2B_control_S3_L008.genecount", sep = "", header = TRUE) #%>% mutate("Strand" = "Forward")
mapped_reverse_control <- sum(df_reverse_3_2B_control_S3_L008.genecount$count)

#3
df_stranded_32_4G_both_S23_L008.genecount <- read.delim("~/bioinfo/Bi623/QAA/star/alignment/stranded_32_4G_both_S23_L008.genecount", sep = "", header = TRUE) #%>% mutate("Strand" = "Forward")
mapped_stranded_both <- sum(df_stranded_32_4G_both_S23_L008.genecount$count)

#4
df_reverse_32_4G_both_S23_L008.genecount <- read.delim("~/bioinfo/Bi623/QAA/star/alignment/reverse_32_4G_both_S23_L008.genecount", sep = "", header = TRUE) #%>% mutate("Strand" = "Forward")
mapped_reverse_both <- sum(df_reverse_32_4G_both_S23_L008.genecount$count)

unmapped_stranded_control = 5664164 + 5228 + 15298 + 239783 + 281888
unmapped_reverse_control = 526681 + 104201 + 15298 + 239783 + 281888
unmapped_stranded_both = 323 + 6 + 0 + 11715997 + 83681
unmapped_reverse_both = 318 + 9 + 0 + 11715997 + 83681

total_stranded_control = unmapped_stranded_control + mapped_stranded_control
total_reverse_control = unmapped_reverse_control + mapped_reverse_control
total_stranded_both = unmapped_stranded_both + mapped_stranded_both
total_reverse_both = unmapped_reverse_both + mapped_reverse_both

stranded_control_percent_mapped = (mapped_stranded_control / (unmapped_stranded_control + mapped_stranded_control))*100

reverse_control_percent_mapped = (mapped_reverse_control / (unmapped_reverse_control + mapped_reverse_control))*100

stranded_both_percent_mapped = (mapped_stranded_both / (unmapped_stranded_both + mapped_stranded_both))*100

reverse_both_percent_mapped = (mapped_reverse_both / (unmapped_reverse_both + mapped_reverse_both))*100

```





